# Система умений игрока

Игрок обладает набором умений, которые он может постепенно изучать в процессе игры

- Очки для изучения зарабатываются во время игры и расходуются при получении новых умений
- Каждое умение имеет свою стоимость
- Между умениями существует **ненаправленный граф связей**
- В начале игры игрок владеет только **одним базовым умением**
- Новое умение можно изучить, только если:
    - У игрока достаточно очков
    - Умение связано (напрямую или косвенно) хотя бы с одним уже изученным умением

---

## Основные принципы

- **Неизменность базового умения** – базовое умение нельзя забыть
- **Требование связности** – все изученные умения должны оставаться связаны с базовым
- **Экономика очков** – изучение тратит очки, забывание возвращает их
- **Консистентность UI** – представления всегда отражают текущее состояние через реактивные обновления

---

## Архитектура MVC

- **Model (`SkillModel`)** – описывает состояние умения и связи в графе
- **Controller (`SkillsController`)** – реализует игровую логику: изучение, забывание, проверка связности
- **View** – подписывается на изменения в `SkillModel` и обновляется автоматически

Такой подход обеспечивает **слабое зацепление**:  
View не знает о логике контроллера и просто реагирует на изменения модели

---

## `SkillModel`

Выступает как **контракт** между контроллером и представлением

**Свойства:**
- `Type` – уникальный идентификатор умения
- `Neighbors` – соседние умения (граф связей)
- `Cost` – стоимость изучения
- `IsBase` – является ли умение базовым (нельзя забыть)
- `IsLearned` – текущее состояние (изучено / нет)
- `CanBeLearned` – можно ли изучить сейчас
- `CanBeForgotten` – можно ли забыть сейчас

---

## Алгоритм проверки связности

Для проверки, что все умения остаются связаны с базовым, используется **алгоритм Тарьяна**:

- Выполняется **поиск в глубину (DFS — Depth-First Search)** от базового умения
- Для каждого узла вычисляются времена входа (`disc`) и минимальные значения (`low`)
- Навыки, удаление которых нарушает связность, определяются как **точки сочленения**
- Такие умения нельзя забывать

Сложность алгоритма: **O(V + E)** – оптимальная для обхода графа

---

## Жизненный цикл

1 **Инициализация**
    - Подписки на изменения очков и действий игрока
    - Загрузка начального состояния моделей

2 **Выбор умения**
    - Обновление статуса выбранного умения
    - Пересчёт точек сочленения

3 **Изучение умения**
    - Проверка условий (очки + связь)
    - Изменение состояния модели
    - Пересчёт связности

4 **Забывание умения**
    - Проверка, что умение не базовое и не критическое
    - Возврат очков и обновление модели
    - Пересчёт связности

5 **Забывание всех умений**
    - Последовательно удаляются все допустимые умения
    - Каждое удаление сопровождается обновлением модели и пересчётом графа~~  
