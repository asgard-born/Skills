# Система умений игрока

Игрок обладает набором умений, которые он может постепенно изучать в процессе игры

- Очки для изучения зарабатываются во время игры и расходуются при получении новых умений
- Каждое умение имеет свою стоимость
- Между умениями существует **ненаправленный граф связей**
- В начале игры игрок владеет только **одним базовым умением**
- Новое умение можно изучить, только если:
    - У игрока достаточно очков
    - Умение связано хотя бы с одним уже изученным умением

---

## Основные принципы

- **Требования связности**:
  - все изученные умения должны оставаться связаны (напрямую или косвенно) с базовым
  - умение может быть забыто только в том случае, если все оставшиеся изученные умения будут иметь связь (прямую или по цепочке) с базовым умением.
- **Неизменность базового умения** – базовое умение нельзя забыть
- **Экономика очков** – изучение тратит очки, забывание возвращает их
- **Консистентность UI** – представления всегда отражают текущее состояние через реактивные обновления
]()
---

## Архитектура MVC

- **Model (`SkillModel`)** – описывает состояние умения и ближайших соседей
- **View (`SkillView`)** – подписывается на изменения от `SkillModel` через реактивные контракты и обновляется автоматически
- **Controller (`SkillsController`)** – реализует игровую логику: изучение/ выбор/ забывание умения/умений, проверка связности умений

Такой подход обеспечивает **слабое зацепление**:  View не знает о логике контроллера и просто реагирует на изменения модели

---

## `SkillModel`

Выступает как **контракт** между контроллером и представлением

**Свойства:**
- `Type` – уникальный идентификатор умения
- `Neighbors` – соседние умения (граф связей)
- `Cost` – стоимость изучения
- `IsBase` – является ли умение базовым (нельзя забыть)
- `IsLearned` – текущее состояние (изучено / нет)
- `CanBeLearned` – можно ли изучить сейчас
- `CanBeForgotten` – можно ли забыть сейчас

---

## Алгоритм проверки связности

Для проверки, что все умения остаются связаны с базовым, используется **алгоритм Тарьяна**:

- Выполняется **поиск в глубину (DFS — Depth-First Search)** от базового умения
- Для каждого узла вычисляются времена входа (`disc`) и минимальные значения (`low`)
- Умения, удаление которых нарушает связность, определяются как **точки сочленения**
- Такие умения нельзя забывать

Сложность алгоритма: **O(V + E)** – оптимальная для обхода графа

---

## Жизненный цикл

### 1 Инициализация
- Подписки на изменения очков и действий игрока
- Инициализация представлений
- Загрузка начального состояния моделей
- Обновление представлений исходя из состояния моделей

### 2 Выбор умения
- Обновление статуса выбранного умения

### 3 Изучение умения
- Проверка условий (очки + связь)
- Изменение состояния модели
- Пересчёт связности

### 4 Забывание умения
- Проверка, что умение не базовое и не критическое
- Возврат очков и обновление модели
- Пересчёт связности

### 5 Забывание всех умений
- Последовательно удаляются все допустимые умения
- Каждое удаление сопровождается обновлением модели и пересчётом графа~~  
