# Умения игрока
Игрок обладает набором умений, которые он может постепенно изучать
- Очки для изучения зарабатываются в процессе игры и расходуются при получении новых умений
- Каждое умение имеет стоимость
- Между умениями существует ненаправленный граф связей
- В начале игры игрок владеет только одним базовым умением
- Новое умение можно изучить, только если выполнены оба условия:
- У игрока достаточно очков для его изучения
- Умение связано хотя бы с одним уже изученным умением
---
## Основные принципы
- **Неизменность базового навыка** – базовые навыки нельзя забыть
- **Требование связности** – все навыки должны оставаться связаны с базовым
- **Экономия очков** – изучение тратит очки, забывание возвращает их
- **Консистентность UI** – view models всегда отражают текущее состояние игры

### SkillViewModel

Выступает как **контракт** между сервисом и представлением, обеспечивая **реактивные обновления** и **слабое зацепление**

**Свойства:**
- `Type` – идентификатор навыка
- `Neighbors` – соседние навыки
- `Cost` – стоимость изучения
- `IsBase` – является ли базовым навыком (нельзя забыть)
- `IsLearned` – изучен ли навык
- `CanBeLearned` – можно ли изучить сейчас
- `CanBeForgotten` – можно ли забыть сейчас

Представления подписываются на изменения `SkillViewModel` через ReactiveProperties/ReactiveCommands, чтобы обновлять UI автоматически

---

## Алгоритм поиска точек сочленения

Сервис использует **алгоритм Тарьяна** для поиска точек сочленения в графе:

- Выполняет **поиск в глубину (DFS — Depth-First Search)** начиная с базового навыка
- Основан на проверенных принципах **computer science**
- Отслеживает **время обнаружения** (`disc`) и **минимальные значения** (`low`), чтобы определить **критические навыки**, те узлы, которые держат граф связанным
- Навыки, удаление которых разрывает связь других изученных с базовым запрещено забывать

Алгоритм работает эффективно — **O(V + E)**, что является оптимальной сложностью для поиска точек сочленения

---

## Эффективность

- **Сложность O(V + E)** – оптимальная для обхода графа
- Выполняется за миллисекунды даже для больших графов навыков
- Запускается только при изменении структуры графа
- Обновляет только затронутые view models, минимизируя лишние изменения
- Реактивная архитектура исключает ненужные перерисовки UI

---

## Как работает сервис

### 1 Инициализация
- Настраивает реактивные подписки на изменения очков и действия игрока
- Инициализирует все view models начальными состояниями

### 2 Выбор навыка
- Обновляет состояние выбранного навыка через view model
- Пересчитывает точки сочленения для текущего состояния графа

### 3 Изучение навыка
- Проверяет условия: достаточно ли очков и есть ли соседний изученный навык
- Помечает навык как изученный и обновляет view model
- Пересчитывает точки сочленения

### 4 Забытие навыка
- Проверяет, что навык не является базовым и не является критическим `(articulation point)`
- Помечает навык как забытый, обновляет view model
- Возвращает очки и пересчитывает точки сочленения

### 5 Забытие всех навыков
- Итеративно удаляет все допустимые навыки с сохранением связности
- Обрабатывает их в порядке, позволяющем забыть все возможные
- Обновляет статус каждого навыка через view model
- Пересчитывает точки сочленения после каждого шага  
